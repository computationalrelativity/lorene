/*
 *  Definition of Lorene class Et_bin_ncp
 *
 */

/*
 *   Copyright (c) 2002 Francois Limousin
 *
 *   This file is part of LORENE.
 *
 *   LORENE is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License version 2
 *   as published by the Free Software Foundation.
 *
 *   LORENE is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with LORENE; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef __ET_BIN_NCP_H_ 
#define __ET_BIN_NCP_H_ 

/*
 * $Id$
 * $Log$
 * Revision 1.4  2003/02/04 16:16:25  f_limousin
 * Add several members and computational routines
 *
 * Revision 1.3  2003/01/20 09:31:56  f_limousin
 * Modification of the standard constructor
 *
 * Revision 1.2  2003/01/14 14:13:25  f_limousin
 * Binary NS with Nonconformally flat metric.
 *
 * Revision 1.1  2002/12/09 10:45:06  f_limousin
 * Definition of class Et_bin_ncp
 *
 *
 *
 * $Header$
 *
 */

// Lorene headers
#include "etoile.h"
#include "metrique.h"
#include "metconf.h"

/**
 * Class for stars in binary systems with a full spatial metric. 
 * 
 * This class is a derived class from {\tt Etoile\_bin }
 *
 * @version #$Id$#
 */
class Et_bin_ncp : public Etoile_bin {

    // Data : 
    // -----
    protected:

    ///  3-metric 
    Metrique met_gamma ;

    ///  flat 3-metric
    Metrique flat ;

    /// Conformal 3-metric (tensor density of weight -2/3)
    Metconf gtilde ;

    ///  Determinant of the 3-metric
    Tenseur gamma ;

    ///  Logarithm of the determinant
    Tenseur loggamma ;

    /** Part of the determinant logarithm 
     *generated principaly by the star. 
     */
    
    Tenseur loggamma_auto ;

    /** Part of the determinant logarithm 
     *  generated principaly by the companion star. 
     */

    Tenseur loggamma_comp ;

    /** Part of the 3_metric  
     * generated principaly by the star. 
     */
    
    Metrique metgamma_auto ;

    /** Part of the 3_metric  
     *  generated principaly by the companion. 
     */

    Metrique metgamma_comp ;

    /** Part of the 3_metric tilde 
     *   generated principaly by the star. 
     */
    Metconf gtilde_auto ;

    /** Part of the 3_metric tilde 
     *  generated principaly by the companion star. 
     */

    Metconf gtilde_comp ;

    /** Part of the scalar $ K_{ij} K^{ij}$
     *  generated by {\tt shift\_auto}, i.e. 
     *   $K_{ij}^{\rm auto} K^{ij}_{\rm auto}$ 
     */
    
    Tenseur kcar_auto ;
       
    /** Part of the scalar $ K_{ij} K^{ij}$
     *  generated by {\tt shift\_auto} and {\tt shift\_comp}, i.e. 
     *    $K_{ij}^{\rm auto} K^{ij}_{\rm comp}$ 
     */

    Tenseur kcar_comp ;
	


    // Constructors - Destructor
    // -------------------------
    public:
	/** Standard constructor. 
	 * 
	 * @param mp_i Mapping on which the star will be defined
	 * @param nzet_i Number of domains occupied by the star
	 * @param relat should be {\tt true} for a relativistic
	 *			star,  {\tt false} for a Newtonian one
	 * @param eos_i Equation of state of the stellar matter
	 * @param irrot should be {\tt true} for an irrotational star, 
	 *		    {\tt false} for a corotating one
	 * @param ref_triad_i  Reference triad ("absolute frame"), with
	 *	    respect to which the components of all the member 
	 *	    {\tt Tenseur}'s are defined, except for {\tt w\_shift}
	 *	    and {\tt ssjm1\_wshift} whose components are defined
	 *	    with respect to the mapping {\tt mp} Cartesian triad. 
	 * @param flat_i flat 3-metric 
	 */
         Et_bin_ncp(Map& mp_i, int nzet_i, bool relat, const Eos& eos_i,
		    bool irrot, const Base_vect& ref_triad_i, 
		    const Metrique& flat_i,const Tenseur_sym& source) ;
		  
        Et_bin_ncp(const Et_bin_ncp& ) ;		/// Copy constructor

	/** Constructor from a file (see {\tt sauve(FILE* )}). 
	 *   
	 * @param mp_i Mapping on which the star will be defined
	 * @param eos_i Equation of state of the stellar matter
	 * @param ref_triad_i  Reference triad ("absolute frame"), with
	 *	    respect to which the components of all the member 
	 *	    {\tt Tenseur}'s are defined, except for {\tt w\_shift}
	 *	    and {\tt ssjm1\_wshift} whose components are defined
	 *	    with respect to the mapping {\tt mp} Cartesian triad. 
	 * @param fich	input file (must have been created by the function
	 *	{\tt sauve})
	 */
	Et_bin_ncp(Map& mp_i, const Eos& eos_i, const Base_vect& ref_triad_i, const Metrique& flat, FILE* fich) ;    		


	virtual ~Et_bin_ncp() ;			/// Destructor
 

    // Mutators / assignment
    // ---------------------
    public:
	/// Assignment to another {\tt Et\_bin\_ncp}
	void operator=(const Et_bin_ncp& ) ;	
	
    // Accessors
    // ---------
    public:

	/// Retunrs the 3-metric
	const Metrique& get_met_gamma() const {return met_gamma;} ;

	/// Retunrs the flat 3-metric
	const Metrique& get_flat() const {return flat;} ;

	/// Returns the conformal 3-metric (tensor density of weight -2/3)
	const Metconf& get_gtilde() const {return gtilde;} ;

	/// Returns the determinant of the 3-metric 
	const Tenseur& get_gamma() const {return gamma;} ;

	/// Returns the logarithm of the determinant
	const Tenseur& get_loggamm() const {return loggamma;} ;

	/** Returns the part of the determinant logarithm generated principaly
	 * by the star
	 */

	const Tenseur& get_loggamma_auto() const {return loggamma_auto;} ;
	
	/** Returns the part of the determinant logarithm generated principaly
	 * by the companion star
	 */
	
	const Tenseur& get_loggamma_comp() const {return loggamma_comp;} ;

	/** Returns the part of the 3-metric principaly generated by the 
	 * star
	 */

	const Metrique& get_metgamma_auto() const {return metgamma_auto;} ;

	/** Returns the part of the 3-metric principaly generated by the 
	 * companion
	 */

	const Metrique& get_metgamma_comp() const {return metgamma_comp;} ;

	/** Returns the part of the 3-metric tilde principaly generated by the 
	 * star
	 */

	const Metconf& get_gtilde_auto() const {return gtilde_auto;} ;
	
	/** Returns the part of the 3-metric tilde principaly generated by the 
	 * companion star
	 */

	const Metconf& get_gtilde_comp() const {return gtilde_comp;} ;

	/** Return the part of the scalar $ K_{ij} K^{ij}$
	 * generated by {\tt shift\_auto}, i.e. 
	 * $K_{ij}^{\rm auto} K^{ij}_{\rm auto}$ 
	 */

	 const Tenseur& get_kcar_auto() const {return kcar_auto;} ;

	/** Return the part of the scalar $ K_{ij} K^{ij}$
	 * generated by {\tt shift\_auto} and {\tt shift\_comp}, i.e. 
         * $K_{ij}^{\rm auto} K^{ij}_{\rm comp}$ 
	 */

	 const Tenseur& get_kcar_comp() const {return kcar_comp;} ;
 


    // Outputs
    // -------
    public:
	virtual void sauve(FILE *) const ;	    /// Save in a file

   protected:
	/// Operator >> (virtual function called by the operator <<). 
	virtual ostream& operator>>(ostream& ) const ;    


    // Global quantities
    // -----------------
    public:
	/// Baryon mass
    	virtual double mass_b() const ;
	
	/// Gravitational mass
    	virtual double mass_g() const ;
	
	/** Absolute coordinate X of the barycenter of the baryon density, 
	 *  defined according to the formula
	 *  \begin{equation}
	 *    X_G := \int gamma^(1/2) \Gamma_{\rm n} \,  n \,  X \, d^3x \ ,  
	 *  \end{equation}
	 *  where $\Gamma_{\rm n}$ is the Lorentz factor between the fluid 
	 *  and Eulerian observers.
	 *  and gamma is the determinant of the metric.
	 */
    	virtual double xa_barycenter() const ;
	

    // Computational routines
    // ----------------------
    public: 
	/** Performs the scalar product of two tensors by contracting
	 *  the last index of {\tt t1} with the first index of {\tt t2}.
	 *  Both indices are supposed to be contravariant, so that a 
	 *  multiplication by $A^2$ is performed to lower one index. 
	 *  For instance, for two vectors $V^i$ and $W^i$, this function
	 *  returns the scalar $h_{ij} V^i W^j = A^2 f_{ij} V^i W^j$.  
	 */
	virtual Tenseur sprod(const Tenseur& t1, const Tenseur& t2) const ; 


	/** Computes {\tt tkij\_auto} from 
	 *  {\tt shift\_auto}, {\tt nnn}.
	 */
	virtual void extrinsic_curvature() ; 


	/** Computes an equilibrium configuration.
	 * 
	 *  The values of {\tt logn\_comp}, {\tt beta\_comp}, {\tt pot\_centri}
	 *  are held fixed during the iteration. 
	 *  
	 *  @param ent_c  [input] Central enthalpy
	 *  @param mermax [input] Maximum number of steps 
	 *  @param mermax_poisson [input]   Maximum number of steps in 
	 *				    Map\_et::poisson
	 *  @param relax_poisson [input]  Relaxation factor in Map\_et::poisson
	 *  @param mermax_potvit [input]  Maximum number of steps in 
	 *				  Map\_radial::poisson\_compact
	 *  @param relax_potvit [input]   Relaxation factor in 
	 *				  Map\_radial::poisson\_compact
	 *  @param thres_adapt  [input]   Threshold on dH/dr for the adaptation 
	 *				  of the mapping
	 *  @param fact [input]    1-D {\tt Tbl} for the input
	 *                          of some factors : \\
	 *          {\tt fact(0)} : A resizing factor for the first shell
	 *  @param diff [output]   1-D {\tt Tbl} for the storage of some
	 *			    error indicators : \\
	 *	    {\tt diff(0)} : Relative change in the enthalpy field
	 *			      between two successive steps \\
	 *	    {\tt diff(1)} : Relative error returned by the routine
	 *				{\tt Etoile\_bin::velocity\_potential}  
	 *	    {\tt diff(2)} : Relative error in the resolution of the
	 *			    Poisson equation for {\tt logn\_auto} \\  
	 *	    {\tt diff(3)} : Relative error in the resolution of the
	 *			    Poisson equation for {\tt beta\_auto} \\  
	 *	    {\tt diff(4)} : Relative error in the resolution of the
	 *			    equation for {\tt shift\_auto} (x comp.) \\  
	 *	    {\tt diff(5)} : Relative error in the resolution of the
	 *			    equation for {\tt shift\_auto} (y comp.) \\  
	 *	    {\tt diff(6)} : Relative error in the resolution of the
	 *			    equation for {\tt shift\_auto} (z comp.)   
	 */
	virtual void equilibrium(double ent_c, int mermax, int mermax_poisson, 
			 double relax_poisson, int mermax_potvit, 
			 double relax_potvit, double thres_adapt, 
			 const Tbl& fact, Tbl& diff) ;	


	/** Computes metric coefficients from known potentials,
	 * when the companion is another star.
	 *
	 *  The calculation is performed starting from the quantities
	 *  {\tt logn\_auto}, {\tt shift\_auto}, {\tt loggamma\_auto},
	 *  {\tt gtilde\_auto}, {\tt comp.logn\_auto}, {\tt comp.shift\_auto},
	 *  {\tt comp.loggamma\_auto}, {\tt comp.gtilde\_auto}
	 *  which are supposed to be up to date.
	 *  From these,  the following fields are updated:
	 *  {\tt logn\_comp}, {\tt shift\_comp}, {\tt loggamma\_comp},
	 *  {\tt gtilde\_comp}, {\tt nnn}, {\tt shift}, {\tt loggamma},
	 *  {\tt gtilde}
	 *  {\tt d\_logn\_auto}, {\tt d\_beta\_auto}, {\tt tkij\_auto},
	 *  {\tt kcar\_auto}.
	 *
	 *  @param comp companion star.
	 *
	 */
	void update_metric(const Et_bin_ncp& comp) ;


	/** Same as {\tt update\_metric(const Et\_bin\_ncp\& )} but with
	 *  relaxation.
	 *
	 *  @param comp companion star.
	 *  @param star_prev previous value of the star. 
	 *  @param relax relaxation parameter. 
	 * 
	 */
	void update_metric(const Et_bin_ncp& comp, const Et_bin_ncp& star_prev, 
			   double relax) ; 


	/** Computes the derivative of metric functions related to the
	 *  companion star.
	 *
	 *  The calculation is performed starting from the quantities
	 *  {\tt comp.d\_logn\_auto},  {\tt comp.d\_beta\_auto},
	 *  {\tt comp.tkij\_auto}
	 *  which are supposed to be up to date.
	 *  From these,  the following fields are updated:
	 *  {\tt d\_logn\_comp}, {\tt d\_beta\_comp}, {\tt tkij\_comp},
	 *  {\tt akcar\_comp}.
	 *
	 *  @param comp companion star.
	 *
	 */
	 void update_metric_der_comp(const Et_bin_ncp& comp) ;



};

#endif
