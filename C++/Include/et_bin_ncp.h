
/*
 *  Definition of Lorene class Et_bin_ncp
 *
 */

/*
 *   Copyright (c) 2002 Francois Limousin
 *
 *   This file is part of LORENE.
 *
 *   LORENE is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License version 2
 *   as published by the Free Software Foundation.
 *
 *   LORENE is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with LORENE; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef __ET_BIN_NCP_H_ 
#define __ET_BIN_NCP_H_ 

/*
 * $Id$
 * $Log$
 * Revision 1.7  2003/06/20 14:12:10  f_limousin
 * Add many members for the derivatives of the lapse, shift and 3-metric. Add a new argument conf_flat in the constructors and a new function equilibrium_spher().
 *
 * Revision 1.6  2003/03/03 19:12:18  f_limousin
 * Add the new members tensor stress and Cmp ssjm1_gtildeij. Change of the triad on which all tensors are calculated. This triad is now the mapping triad.
 *
 * Revision 1.5  2003/02/12 18:53:33  f_limousin
 * Add the members metgamma_auto and metgamma_comp.
 *
 * Revision 1.4  2003/02/04 16:16:25  f_limousin
 * Add several members and computational routines
 *
 * Revision 1.3  2003/01/20 09:31:56  f_limousin
 * Modification of the standard constructor
 *
 * Revision 1.2  2003/01/14 14:13:25  f_limousin
 * Binary NS with Nonconformally flat metric.
 *
 * Revision 1.1  2002/12/09 10:45:06  f_limousin
 * Definition of class Et_bin_ncp
 *
 *
 *
 * $Header$
 *
 */

// Lorene headers
#include "etoile.h"
#include "metrique.h"
#include "metconf.h"

/**
 * Class for stars in binary systems with a full spatial metric. 
 * 
 * This class is a derived class from {\tt Etoile\_bin }
 *
 * @version #$Id$#
 */
class Et_bin_ncp : public Etoile_bin {

    // Data : 
    // -----
    protected:

    ///  3-metric 
    Metrique met_gamma ;

    ///  flat 3-metric
    Metrique flat ;

    /// Conformal 3-metric (tensor density of weight -2/3)
    Metconf gtilde ;

    ///  3-metric generated principaly by the star
    Metrique metgamma_auto ;

    ///  3-metric generated principaly by the companion star.
    Metrique metgamma_comp ;


    Tenseur dcov_logn_auto ;
    Tenseur dcov_logn ;
    Tenseur dcon_logn ;
    Tenseur dcondcov_nnn ;
    Tenseur dcondcov_logn_auto ;
    Tenseur dcovdcov_logn_auto ;
    Tenseur lap_logn_auto ;
   
    ///  Determinant of the 3-metric
    Tenseur gamma ;

    /** Part of the determinant logarithm 
     *generated principaly by the star. 
     */    
    Tenseur a_car_auto ;

    /** Part of the determinant logarithm 
     *  generated principaly by the companion star. 
     */
    Tenseur a_car_comp ;

   
    Tenseur dcov_acar ;
    Tenseur dcon_acar ;
    Tenseur dcov_acar_auto ;
    Tenseur dcon_acar_auto ;
    Tenseur dcondcov_acar_auto ;
    Tenseur dcovdcov_acar_auto ;
    Tenseur lap_acar_auto ;
    Tenseur dcovdcon_shift_auto ;
    Tenseur diffdidj_shift_autoj ; 
    Tenseur lap_shift_auto ;

    /** Part of the 3_metric tilde 
     *   generated principaly by the star. 
     */
    Metconf gtilde_auto ;

    /** Part of the 3_metric tilde 
     *  generated principaly by the companion star. 
     */
    Metconf gtilde_comp ;


    Tenseur lap_gtilde_auto ;


    /** Part of the scalar $ K_{ij} K^{ij}$
     *  generated by {\tt shift\_auto}, i.e. 
     *   $K_{ij}^{\rm auto} K^{ij}_{\rm auto}$ 
     */    
    Tenseur kcar_auto ;
       
    /** Part of the scalar $ K_{ij} K^{ij}$
     *  generated by {\tt shift\_auto} and {\tt shift\_comp}, i.e. 
     *    $K_{ij}^{\rm auto} K^{ij}_{\rm comp}$ 
     */
    Tenseur kcar_comp ;

    Tenseur kcar_cov ;

    /** Spatial part of the stress energy tensor with respect to the 
     *  eulerian observer.
     */
    Tenseur stress ;

    /** Effective source at the previous step for the resolution of 
     *  the Poisson equation for {\tt loggamma\_auto} by means of
     *  {\tt Map\_et::poisson}.
     */
    Cmp ssjm1_a_car ; 

    /** Effective source at the previous step for the resolution of 
     *  the Poisson equation for {\tt gtilde00\_auto} by means of
     *  {\tt Map\_et::poisson}.
     */
    Cmp ssjm1_gtilde00 ; 
	
    /** Effective source at the previous step for the resolution of 
     *  the Poisson equation for {\tt gtilde10\_auto} by means of
     *  {\tt Map\_et::poisson}.
     */
    Cmp ssjm1_gtilde10 ;
 
    /** Effective source at the previous step for the resolution of 
     *  the Poisson equation for {\tt gtilde20\_auto} by means of
     *  {\tt Map\_et::poisson}.
     */
    Cmp ssjm1_gtilde20 ; 

    /** Effective source at the previous step for the resolution of 
     *  the Poisson equation for {\tt gtilde11\_auto} by means of
     *  {\tt Map\_et::poisson}.
     */
    Cmp ssjm1_gtilde11 ; 

    /** Effective source at the previous step for the resolution of 
     *  the Poisson equation for {\tt gtilde21\_auto} by means of
     *  {\tt Map\_et::poisson}.
     */
    Cmp ssjm1_gtilde21 ; 

    /** Effective source at the previous step for the resolution of 
     *  the Poisson equation for {\tt gtilde22\_auto} by means of
     *  {\tt Map\_et::poisson}.
     */
    Cmp ssjm1_gtilde22 ; 

    /**
     * Function used to construct the part of $a_car}$ generated by the star 
     * from the total $a_car$. Only used for a binary system.
     * 
     * Mainly this {\tt Cmp} is 1 around the star and 0 around the companion
     * and the sum of {tt decouple} for the star and his companion is 1 
     * everywhere.
     */
    Cmp decouple ;

    /** Indicator of conformally flat metric. 1 for a conformally flat one 
     *  and 0 for a general metric
     */
    bool conf_flat ;
    


    // Constructors - Destructor
    // -------------------------
    public:
	/** Standard constructor. 
	 * 
	 * @param mp_i Mapping on which the star will be defined
	 * @param nzet_i Number of domains occupied by the star
	 * @param relat should be {\tt true} for a relativistic
	 *			star,  {\tt false} for a Newtonian one
	 * @param eos_i Equation of state of the stellar matter
	 * @param irrot should be {\tt true} for an irrotational star, 
	 *		    {\tt false} for a corotating one
	 * @param mapping_triad  Triad with
	 *	    respect to which the components of all the member 
	 *	    {\tt Tenseur}'s are defined.
	 * @param flat_i flat 3-metric 
	 */
         Et_bin_ncp(Map& mp_i, int nzet_i, bool relat, const Eos& eos_i,
		    bool irrot, bool conf_flat0, const Base_vect& mapping_triad, 
		    const Metrique& flat_i,const Tenseur_sym& source) ;
		  
        Et_bin_ncp(const Et_bin_ncp& ) ;		/// Copy constructor

	/** Constructor from a file (see {\tt sauve(FILE* )}). 
	 *   
	 * @param mp_i Mapping on which the star will be defined
	 * @param eos_i Equation of state of the stellar matter
	 * @param mapping_triad  Triad with
	 *	    respect to which the components of all the member 
	 *	    {\tt Tenseur}'s are defined.
	 * @param fich	input file (must have been created by the function
	 *	{\tt sauve})
	 */
	Et_bin_ncp(Map& mp_i, const Eos& eos_i, const Base_vect& mapping_triad,
		   const Metrique& flat, FILE* fich) ;    		


	virtual ~Et_bin_ncp() ;			/// Destructor
 

    // Mutators / assignment
    // ---------------------
    public:
	/// Assignment to another {\tt Et\_bin\_ncp}
	void operator=(const Et_bin_ncp& ) ;	
	
    // Accessors
    // ---------
    public:

	/// Retunrs the 3-metric
	const Metrique& get_met_gamma() const {return met_gamma;} ;

	/// Retunrs the flat 3-metric
	const Metrique& get_flat() const {return flat;} ;

	/// Returns the conformal 3-metric (tensor density of weight -2/3)
	const Metconf& get_gtilde() const {return gtilde;} ;

	/// Retunrs the 3-metric generated principaly by the star
	const Metrique& get_metgamma_auto() const {return metgamma_auto;} ;

	/// Retunrs the 3-metric generated principaly by the companion star.
	const Metrique& get_metgamma_comp() const {return metgamma_comp;} ;

	const Tenseur& get_dcov_lognauto() const {return dcov_logn_auto;} ;
	const Tenseur& get_dcov_logn() const {return dcov_logn;} ;
	const Tenseur& get_dcon_logn() const {return dcon_logn;} ;


	/// Returns the determinant of the 3-metric 
	const Tenseur& get_gamma() const {return gamma;} ;

	/** Returns the part of the determinant logarithm generated principaly
	 * by the star
	 */

	const Tenseur& get_acar_auto() const {return a_car_auto;} ;
	
	/** Returns the part of the determinant logarithm generated principaly
	 * by the companion star
	 */
	
	const Tenseur& get_acar_comp() const {return a_car_comp;} ;

	const Tenseur& get_dcov_acar() const {return dcov_acar;} ;
	const Tenseur& get_dcon_acar() const {return dcon_acar;} ;
	const Tenseur& get_dcov_acarauto() const {return dcov_acar_auto;} ;
	const Tenseur& get_dcon_acarauto() const {return dcon_acar_auto;} ;


	/** Returns the part of the 3-metric tilde principaly generated by the 
	 * star
	 */

	const Metconf& get_gtilde_auto() const {return gtilde_auto;} ;
	
	/** Returns the part of the 3-metric tilde principaly generated by the 
	 * companion star
	 */

	const Metconf& get_gtilde_comp() const {return gtilde_comp;} ;

	/** Return the part of the scalar $ K_{ij} K^{ij}$
	 * generated by {\tt shift\_auto}, i.e. 
	 * $K_{ij}^{\rm auto} K^{ij}_{\rm auto}$ 
	 */

	 const Tenseur& get_kcar_auto() const {return kcar_auto;} ;

	/** Return the part of the scalar $ K_{ij} K^{ij}$
	 * generated by {\tt shift\_auto} and {\tt shift\_comp}, i.e. 
         * $K_{ij}^{\rm auto} K^{ij}_{\rm comp}$ 
	 */

	 const Tenseur& get_kcar_comp() const {return kcar_comp;} ;

	/** Return the spatial part of the stress energy tensor with 
	 *   respect to the eulerian observer.
	 */

      	const Tenseur& get_stress() const {return stress;} ;

	/** Returns {\tt true} for a conformally flat metric, {\tt false} for 
	 *  a general one
	 */
	bool is_conf_flat() const {return conf_flat; } ; 

	const Cmp& get_decouple() const {return decouple;} ;


    // Outputs
    // -------
    public:
	virtual void sauve(FILE *) const ;	    /// Save in a file

   protected:
	/// Operator >> (virtual function called by the operator <<). 
	virtual ostream& operator>>(ostream& ) const ;    


    // Global quantities
    // -----------------
    public:
	/// Baryon mass
    	virtual double mass_b() const ;
	
	/// Gravitational mass
    	virtual double mass_g() const ;
	
	/** Absolute coordinate X of the barycenter of the baryon density, 
	 *  defined according to the formula
	 *  \begin{equation}
	 *    X_G := \int gamma^(1/2) \Gamma_{\rm n} \,  n \,  X \, d^3x \ ,  
	 *  \end{equation}
	 *  where $\Gamma_{\rm n}$ is the Lorentz factor between the fluid 
	 *  and Eulerian observers.
	 *  and gamma is the determinant of the metric.
	 */
    	virtual double xa_barycenter() const ;
	

    // Computational routines
    // ----------------------
    public: 
	/** Performs the scalar product of two tensors by contracting
	 *  the last index of {\tt t1} with the first index of {\tt t2}.
	 *  Both indices are supposed to be contravariant, so that a 
	 *  multiplication by $A^2$ is performed to lower one index. 
	 *  For instance, for two vectors $V^i$ and $W^i$, this function
	 *  returns the scalar $h_{ij} V^i W^j = A^2 f_{ij} V^i W^j$.  
	 */
	virtual Tenseur sprod(const Tenseur& t1, const Tenseur& t2) const ; 


	/** Computes {\tt tkij\_auto} from 
	 *  {\tt shift\_auto}, {\tt nnn}.
	 */
	virtual void extrinsic_curvature() ; 


	/** Computes an equilibrium configuration.
	 * 
	 *  The values of {\tt logn\_comp}, {\tt beta\_comp}, {\tt pot\_centri}
	 *  are held fixed during the iteration. 
	 *  
	 *  @param ent_c  [input] Central enthalpy
	 *  @param mermax [input] Maximum number of steps 
	 *  @param mermax_poisson [input]   Maximum number of steps in 
	 *				    Map\_et::poisson
	 *  @param relax_poisson [input]  Relaxation factor in Map\_et::poisson
	 *  @param mermax_potvit [input]  Maximum number of steps in 
	 *				  Map\_radial::poisson\_compact
	 *  @param relax_potvit [input]   Relaxation factor in 
	 *				  Map\_radial::poisson\_compact
	 *  @param thres_adapt  [input]   Threshold on dH/dr for the adaptation 
	 *				  of the mapping
	 *  @param fact [input]    1-D {\tt Tbl} for the input
	 *                          of some factors : \\
	 *          {\tt fact(0)} : A resizing factor for the first shell
	 *  @param diff [output]   1-D {\tt Tbl} for the storage of some
	 *			    error indicators : \\
	 *	    {\tt diff(0)} : Relative change in the enthalpy field
	 *			      between two successive steps \\
	 *	    {\tt diff(1)} : Relative error returned by the routine
	 *				{\tt Etoile\_bin::velocity\_potential}  
	 *	    {\tt diff(2)} : Relative error in the resolution of the
	 *			    Poisson equation for {\tt logn\_auto} \\  
	 *	    {\tt diff(3)} : Relative error in the resolution of the
	 *			    Poisson equation for {\tt beta\_auto} \\  
	 *	    {\tt diff(4)} : Relative error in the resolution of the
	 *			    equation for {\tt shift\_auto} (x comp.) \\  
	 *	    {\tt diff(5)} : Relative error in the resolution of the
	 *			    equation for {\tt shift\_auto} (y comp.) \\  
	 *	    {\tt diff(6)} : Relative error in the resolution of the
	 *			    equation for {\tt shift\_auto} (z comp.)   
	 */
	virtual void equilibrium(double ent_c, int mermax, int mermax_poisson, 
			 double relax_poisson, int mermax_potvit, 
			 double relax_potvit, double thres_adapt, 
			 const Tbl& fact, Tbl& diff) ;	


	/** Computes metric coefficients from known potentials,
	 * when the companion is another star.
	 *
	 *  The calculation is performed starting from the quantities
	 *  {\tt logn\_auto}, {\tt shift\_auto}, {\tt loggamma\_auto},
	 *  {\tt gtilde\_auto}, {\tt comp.logn\_auto}, {\tt comp.shift\_auto},
	 *  {\tt comp.loggamma\_auto}, {\tt comp.gtilde\_auto}
	 *  which are supposed to be up to date.
	 *  From these,  the following fields are updated:
	 *  {\tt logn\_comp}, {\tt shift\_comp}, {\tt loggamma\_comp},
	 *  {\tt gtilde\_comp}, {\tt nnn}, {\tt shift}, {\tt loggamma},
	 *  {\tt gtilde}
	 *  {\tt d\_logn\_auto}, {\tt d\_beta\_auto}, {\tt tkij\_auto},
	 *  {\tt kcar\_auto}.
	 *
	 *  @param comp companion star.
	 *
	 */
	void update_metric(const Et_bin_ncp& comp) ;

	/** Same as {\tt update\_metric(const Etoile\_bin\& )} to update
	 *  logn_comp and loggamma_auto when only {\tt beta\_auto} and 
	 *  {\logn\_auto} are saved.
	 */
	void update_metric_init(const Et_bin_ncp& comp) ;

	/** Same as {\tt update\_metric(const Et\_bin\_ncp\& )} but with
	 *  relaxation.
	 *
	 *  @param comp companion star.
	 *  @param star_prev previous value of the star. 
	 *  @param relax relaxation parameter. 
	 * 
	 */
	void update_metric(const Et_bin_ncp& comp, const Et_bin_ncp& star_prev, 
			   double relax) ; 


	/** Computes the derivative of metric functions related to the
	 *  companion star.
	 *
	 *  The calculation is performed starting from the quantities
	 *  {\tt comp.d\_logn\_auto},  {\tt comp.d\_beta\_auto},
	 *  {\tt comp.tkij\_auto}
	 *  which are supposed to be up to date.
	 *  From these,  the following fields are updated:
	 *  {\tt d\_logn\_comp}, {\tt d\_beta\_comp}, {\tt tkij\_comp},
	 *  {\tt akcar\_comp}.
	 *
	 *  @param comp companion star.
	 *
	 */
	 void update_metric_der_comp(const Et_bin_ncp& comp) ;

	/** Computes the hydrodynamical quantities relative to the Eulerian
	 *  observer from those in the fluid frame, as well as 
	 *  {\tt wit\_w} and {\tt loggam}.  
	 *
	 *  The calculation is performed starting from the quantities
	 *  {\tt ent}, {\tt ener}, {\tt press}, {\tt gtilde} and {\tt bsn},  
	 *  which are supposed to be up to date.  
	 *  From these,  the following fields are updated:
	 *  {\tt gam\_euler}, {\tt u\_euler}, {\tt ener\_euler}, {\tt s\_euler}, 
	 *  {\tt wit\_w}, {\tt stress} and {\tt loggam}. 
	 * 
	 */
	virtual void hydro_euler() ; 

	/** Computes the quantities {\tt bsn} and {\tt pot\_centri}.
	 * 
	 *  The calculation is performed starting from the quantities
	 *  {\tt nnn}, {\tt shift},  {\tt a\_car},  
	 *  which are supposed to be up to date.  
	 * 
	 *  @param omega  angular velocity with respect to an asymptotically 
	 *		  inertial observer
	 *  @param x_axe  absolute X coordinate of the rotation axis
	 */
	virtual void kinematics(double omega, double x_axe) ; 

	/** Performs a relaxation on {\tt ent}, {\tt logn\_auto},
	 *  {\tt beta\_auto} and {\tt shift\_auto}. 
	 * 
	 *  @param star_prev   [input] star at the previous step.
	 *  @param relax_ent   [input] Relaxation factor for {\tt ent} 
	 *  @param relax_met   [input] Relaxation factor for {\tt logn\_auto},
	 *			       {\tt beta\_auto}, {\tt shift\_auto}, 
	 *			       only if {\tt (mer \% fmer\_met == 0)}.
	 *  @param mer	       [input] Step number
	 *  @param fmer_met    [input] Step interval between metric updates
	 */
	void relaxation(const Et_bin_ncp& star_prev, double relax_ent, 
			double relax_met, int mer, int fmer_met) ;

	/** Computes a spherical static configuration. 
	 * 
	 *  @param ent_c [input] central value of the enthalpy
	 *  @param precis [input] threshold in the relative difference between 
	 *	the enthalpy fields of two consecutive steps
	 *	to stop the iterative procedure (default value: 1.e-14)
	 */
	virtual void equilibrium_spher(double ent_c, double precis = 1.e-14) ; 
 

	friend class Bin_ns_ncp ;

};

#endif
