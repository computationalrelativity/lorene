/*
 *  Definition of Lorene class Black_hole
 *
 */

/*
 *   Copyright (c) 2005-2006 Keisuke Taniguchi
 *
 *   This file is part of LORENE.
 *
 *   LORENE is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License version 2
 *   as published by the Free Software Foundation.
 *
 *   LORENE is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with LORENE; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef __BLACKHOLE_H_ 
#define __BLACKHOLE_H_ 

/*
 * $Id$
 * $Log$
 * Revision 1.1  2007/06/22 01:02:57  k_taniguchi
 * *** empty log message ***
 *
 *
 * $Header$
 *
 */

// External classes which appear in the declaration of class Black_hole:
//class YYY ; 

// Headers Lorene
#include "metric.h"

                    //-------------------------------//
                    //     Base class Black_hole     //
                    //-------------------------------//

/**
 * Base class for black holes.
 * \ingroup(star)
 *
 * According to the 3+1 formalism, the spacetime metric is written
 * \f[
 *   ds^2 = - \alpha^2 dt^2 + \gamma_{ij} ( dx^i + \beta^i dt )
 *                                        ( dx^j + \beta^j dt )
 * \f]
 * where \f$\gamma_{ij}\f$ is the spatial metric.
 * 
 */
class Black_hole {

    // Data : 
    // -----
    protected:
        /// Mapping associated with the black hole
        Map& mp ;

	/** \c true  for a Kerr-Schild background, \c false  for
	 *  a conformally flat background
	 */
	bool kerrschild ;

	/// Gravitational mass of BH
	double mass_bh ;

	// Metric quantities
	// -----------------

	/// Lapse function generated by the black hole
	Scalar lapse ;  // lapse = lapse_rs + lapse_bh

	/// Part of the lapse function from the numerical computation
	Scalar lapse_rs ;

	/// Part of the lapse function from the analytic background
	Scalar lapse_bh ;

	/// Shift vector generated by the black hole
	Vector shift ;  // shift = shift_rs + shift_bh

	/// Part of the shift vector from the numerical computation
	Vector shift_rs ;

	/// Part of the shift vector from the analytic background
	Vector shift_bh ;

	/// Conformal factor generated by the black hole
	Scalar confo ;

	/// Trace of the extrinsic curvature
	//	Scalar trace_k ;

	/** Extrinsic curvature tensor \f$\ A^{ij}\f$
	 *  generated by \c shift , \c lapse , and
	 *  \c confo .
	 */
	Sym_tensor taij ;

	/// Part of the extrinsic curvature tensor
	Sym_tensor taij_rs ;

	/** Part of the scalar \f$\eta_{ik} \eta_{jl} A^{ij} A^{kl}\f$
	 *  generated by \f$A_{ij}\f$
	 */
	Scalar taij_quad ;

	/// Part of the scalar
	Scalar taij_quad_rs ;

	/** Flat metric defined on the mapping (Spherical components
	 *  with respect to the mapping of the black hole ).
	 */
	Metric_flat flat ;

	/// Conformal metric \f$\tilde \gamma_{ij}\f$
	//	Metric tgij ;

    // Derived data : 
    // ------------
    protected:
	mutable double* p_mass_irr ;  /// Irreducible mass of the black hole

	mutable double* p_mass_adm ;  /// ADM mass

	mutable double* p_mass_kom ;  /// Komar mass

	mutable double* p_rad_ah ; /// Radius of the apparent horizon

    // Constructors - Destructor
    // -------------------------
    public:

	/** Standard constructor.
	 *
	 *  @param mp_i Mapping on which the black hole will be defined
	 */
	Black_hole(Map& mp_i, bool Kerr_schild, double massbh) ;

	Black_hole(const Black_hole& ) ;       ///< Copy constructor

	/** Constructor from a file (see \c sauve(FILE*) )
	 *
	 *  @param mp_i Mapping on which the black hole will be defined
	 *  @param fich input file (must have been created by the function
	 *         \c sauve )
	 */
	Black_hole(Map& mp_i, FILE* fich) ;    		

	virtual ~Black_hole() ;			///< Destructor
 

    // Memory management
    // -----------------
    protected:
	/// Deletes all the derived quantities
	virtual void del_deriv() const ;

	/// Sets to \c 0x0 all the pointers on derived quantities
	void set_der_0x0() const ;


    // Mutators / assignment
    // ---------------------
    public:
	/// Assignment to another \c Black_hole
	void operator=(const Black_hole&) ;

	/// Read/write of the mapping
	Map& set_mp() {return mp; } ;

	/// Read/write of the gravitational mass of BH [{\tt m\_unit}]
	double& set_mass_bh() {return mass_bh; } ;

    // Accessors
    // ---------
    public:
	/// Returns the mapping
	const Map& get_mp() const {return mp; } ;

	/** Returns \c true  for a Kerr-Schild background, \c false  for
	 *  a Conformally flat one
	 */
	bool is_kerrschild() const {return kerrschild; } ;

	/// Returns the gravitational mass of BH [{\tt m\_unit}]
	double get_mass_bh() const {return mass_bh; } ;

	/// Returns the lapse function generated by the black hole
	const Scalar& get_lapse() const {return lapse; } ;

	/** Returns the part of the lapse function from
	 *  the numerical computation
	 */
	const Scalar& get_lapse_rs() const {return lapse_rs; } ;

	/// Returns the shift vector generated by the black hole
	const Vector& get_shift() const {return shift; } ;

	/** Returns the part of the shift vector from
	 *  the numerical computation
	 */
	const Vector& get_shift_rs() const {return shift_rs; } ;

	/// Returns the conformal factor generated by the black hole
	const Scalar& get_confo() const {return confo; } ;

    // Outputs
    // -------
    public:
	virtual void sauve(FILE *) const ;	    ///< Save in a file
    
	/// Display
	friend ostream& operator<<(ostream& , const Black_hole& ) ;	

    protected:
	/// Operator >> (virtual function called by the operator <<)
	virtual ostream& operator>>(ostream& ) const ;

    // Global quantities
    // -----------------
    public:
	/// Irreducible mass of the black hole
	virtual double mass_irr() const ;

	/// ADM mass
	virtual double mass_adm() const ;

	/// Komar mass
	virtual double mass_kom() const ;

	/// Radius of the apparent horizon
	virtual double rad_ah() const ;

    // Computational routines
    // ----------------------
    public:
	/** Boundary condition on the apparent horizon of the black hole
	 *  for the lapse function: 2-D \c Valeur
	 */
	const Valeur bc_lapse(bool neumann, bool first) const ;

	/** Boundary condition on the apparent horizon of the black hole
	 *  for the shift vector of the \fx\f direction: 2-D \c Valeur
	 */
	const Valeur bc_shift_x(double omega_r) const ;

	/** Boundary condition on the apparent horizon of the black hole
	 *  for the shift vector of the \fy\f direction: 2-D \c Valeur
	 */
	const Valeur bc_shift_y(double omega_r) const ;

	/** Boundary condition on the apparent horizon of the black hole
	 *  for the shift vector of the \fz\f direction: 2-D \c Valeur
	 */
	const Valeur bc_shift_z() const ;

	/** Boundary condition on the apparent horizon of the black hole
	 *  for the conformal factor: 2-D \c Valeur
	 */
	const Valeur bc_confo() const ;	

	/// Computes the background metric quantities
	void update_metric() ;

	/** Computes \c taij , \c taij_quad  from \c shift , \c lapse ,
	 *  \c confo .
	 */
	void extr_curv_bh() ;

	/** Computes a spherical, static black-hole by giving boundary
	 *  conditions on the apparent horizon.
	 *
	 *  @param neumann [input] \c true  for the neumann bc, \c false  for
	 *                 the dirichlet one for the lapse
	 *  @param first [input] \c true  for the first type of bc,
	 *               \c false  for the second type
	 *  @param precis [input] threshold in the relative difference of
	 *                a metric quantity between two succesive steps
	 *                to stop the iterative procedure
	 *                (default value: 1.e-14)
	 */
	void equilibrium_spher(bool neumann, bool first,
			       double precis = 1.e-14) ;

	/** Sets the metric quantities to a spherical, static blach-hole
	 *  analytic solution
	 *
	 *  @param neumann [input] \c true  for the neumann bc, \c false  for
	 *                 the dirichlet one for the lapse
	 *  @param first [input] \c true  for the first type of bc,
	 *               \c false  for the second type
	 */
	void static_bh(bool neumann, bool first) ;

	/** Computes a radius of apparent horizon (excised surface)
	 *  in isotropic coordinates
	 *
	 *  @param neumann [input] \c true  for the neumann bc, \c false  for
	 *                 the dirichlet one for the lapse
	 *  @param first [input] \c true  for the first type of bc,
	 *               \c false  for the second type
	 */
	double rah_iso(bool neumann, bool first) const ;

	/** Expresses the areal radial coordinate
	 *  by that in spatially isotropic coordinates
	 *
	 *  @param neumann [input] \c true  for the neumann bc, \c false  for
	 *                 the dirichlet one for the lapse
	 *  @param first [input] \c true  for the first type of bc,
	 *               \c false  for the second type
	 */
	const Scalar r_coord(bool neumann, bool first) const ;

};
ostream& operator<<(ostream& , const Black_hole& ) ;

#endif
